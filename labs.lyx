#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extbook
\begin_preamble
\usepackage{minted}
\usepackage[dvipsnames]{xcolor}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\font_cjk bsmi
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=lines,breaklines=true,bgcolor={gray!5},numbers=left,breaksymbol={},fontfamily=tt,language=rust,tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
The Guide to Chron
\color red
O
\color inherit
S
\end_layout

\begin_layout Author
Betty Liu u2061245
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction to ChronOS
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/2023cse/project/Black_monolith_3_bold.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
These lab is running and tested on Linux (Debian) and Windows 10 for now.
 Please feel free to raise issue at GitHub if any error occur.
\end_layout

\begin_layout Standard
Please ensure to stay updated with the GitHub repo 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://github.com/acyanbird/chronos-labsheet"
literal "false"

\end_inset

 to obtain the latest version of the lab sheet.
\end_layout

\begin_layout Standard
All code available at GitHub 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/acyanbird/chronos_labs/
\end_layout

\end_inset

 Please see different branch for each stage.
\end_layout

\begin_layout Subsection*

\series bold
Objective:
\end_layout

\begin_layout Standard
In this lab, you will learn to create a simple operating system using the
 Rust programming language.
 Operating systems are complex pieces of software that manage hardware resources
 and provide services to other software applications.
 This lab will introduce you to the basics of operating system development,
 focusing on the foundational components.
\end_layout

\begin_layout Standard
After completing the code, you can compare your own code or start development
 directly based on a specific branch.
 Skip the tedious preparation work and dive straight into your favorite
 area.
\end_layout

\begin_layout Standard
You can get the code from each task by
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

git checkout <branch-name>
\end_layout

\begin_layout Plain Layout

# for example
\end_layout

\begin_layout Plain Layout

git checkout lab2-3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to work from existing branch
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# like you currently on lab2-3 and want to work on it
\end_layout

\begin_layout Plain Layout

git checkout -b <your-branch-name>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*

\series bold
Learning Order:
\end_layout

\begin_layout Standard
Lab 0 is a simple tutorial on the Rust language.
 You can skip directly to Lab 1 for learning.
 I will provide a link to return to Lab 0 later.
 Please complete Lab 1 and Lab 2 in sequence, and then you can choose to
 proceed to either Lab 3 or Lab 4.
 These two labs are independent of each other.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 13-06-49.png
	scale 40

\end_inset


\end_layout

\begin_layout Chapter
Lab 0 - Introduction to Rust Programming language
\end_layout

\begin_layout Standard
You can start from Lab 1 directly, you will jump back to here if you encounter
 new component from Rust.
\end_layout

\begin_layout Section
Objectives
\end_layout

\begin_layout Standard
Since this project uses Rust as the programming language, and there are
 no specific university courses for it, this lab will introduce you to some
 fundamental syntax to help you get started.
 You don't need to read through this Lab completely right now.
 Throughout the subsequent implementation of the operating system, if you
 encounter new Rust content, we will reference you back to the relevant
 sections of Lab 0.
 Combining examples will help you better understand their application.
\end_layout

\begin_layout Section
Install Rust
\begin_inset CommandInset label
LatexCommand label
name "sec:Install-Rust"

\end_inset


\end_layout

\begin_layout Standard
Rustup is used to install and managed Rust.
 You can check if your machine is already install Rust by typing rustc --version
 in your console.
 
\end_layout

\begin_layout Standard
If not, for installation on Unix-like machine (e.g.
 MacOS, Linux) input this in terminal
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,fontfamily=rm,fontsize={\footnotesize},breaklines=true"
inline false
status open

\begin_layout Plain Layout

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For windows users install
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=bash"
inline false
status open

\begin_layout Plain Layout

https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/
\end_layout

\begin_layout Plain Layout

rustup-init.exe
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integrated Development Environment
\begin_inset CommandInset label
LatexCommand label
name "subsec:Integrated-Development-Environme"

\end_inset


\end_layout

\begin_layout Standard
I highly recommend using an IDE for development.
 Currently, there are not many IDEs that support Rust.
 Here, I recommend 
\begin_inset CommandInset href
LatexCommand href
name "Visual Studio Code"
target "https://code.visualstudio.com/"
literal "false"

\end_inset

 + 
\begin_inset CommandInset href
LatexCommand href
name "rust-analyzer entension"
target "https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer"
literal "false"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "RustRover"
target "https://www.jetbrains.com/zh-cn/rust/"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Section
Hello World
\end_layout

\begin_layout Standard
We will use cargo to create the basic framework for the project.
 Cargo is Rust’s build system and package manager and it should be installed
 by rustup.
 You could check it by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo --version
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create project by
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo new hello
\end_layout

\begin_layout Plain Layout

cd hello
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will also generate an empty git repository for version control, and a
 cargo.toml that provides project basic information and dependency.
 We could ignore it right now.
 The file structure is like:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-11 23-19-08.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
project structure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Cargo.toml: This is the configuration file for your Rust project.
 It contains metadata about the project, such as its name, version, dependencies
, and other settings.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
src/directory: This directory is where you put your source code files.
 It contains your project's main code.
 You will often have one or more Rust source files (.rs) in this directory.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
main.rs: This is the primary entry point for your Rust application.
 It typically contains the main function, which is the starting point of
 your program.
 
\end_layout

\begin_layout Standard
The main.rs created by cargo is a simple program that would print Hello,
 world! It is similar to C.
 To run project use 
\series bold
cargo run 
\series default
command in terminal.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

fn main() {
\end_layout

\begin_layout Plain Layout

    println!("Hello, world!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Variables 
\begin_inset CommandInset label
LatexCommand label
name "sec:Variables"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Variables:
\end_layout

\begin_layout Itemize
Variables in Rust are declared using the let keyword.
\end_layout

\begin_layout Itemize
By default, variables in Rust are immutable, which means their values cannot
 be changed once assigned.
 To make a variable mutable, you use the mut keyword.
\end_layout

\begin_layout Itemize
You can reassign values to mutable variables, but their types must remain
 the same.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Declare an immutable integer variable
\end_layout

\begin_layout Plain Layout

let x = 10;
\end_layout

\begin_layout Plain Layout

// Declare a mutable integer variable
\end_layout

\begin_layout Plain Layout

let mut y = 20;
\end_layout

\begin_layout Plain Layout

// Reassign a value to the mutable variable
\end_layout

\begin_layout Plain Layout

y = 30;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Constants:
\end_layout

\begin_layout Itemize
Constants in Rust are declared using the const keyword.
\end_layout

\begin_layout Itemize
Constants must have an explicitly defined type and must have a fixed, compile-ti
me determined value.
\end_layout

\begin_layout Itemize
Conventionally, constants are named using all uppercase letters and underscores
 to separate words.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

// Declare an integer constant
\end_layout

\begin_layout Plain Layout

const MAX_VALUE: i32 = 100;
\end_layout

\begin_layout Plain Layout

// Declare a string constant
\end_layout

\begin_layout Plain Layout

const GREETING: &str = "Hello, Rust!";
\end_layout

\end_inset


\end_layout

\begin_layout Section
Attributes
\begin_inset CommandInset label
LatexCommand label
name "sec:Attributes"

\end_inset


\end_layout

\begin_layout Standard
Attributes in Rust are metadata applied to modules, crates, functions, structs,
 or other items.
 They can instruct the compiler to perform specific tasks or apply certain
 properties to the item they annotate.
 Attributes can be divided into two main categories: Inner Attributes and
 Outer Attributes.
\end_layout

\begin_layout Itemize
Outer Attributes (#[outer_attribute]): Applied to the item that follows
 them.
 They are used to set attributes or give instructions related to the item
 directly below them.
\end_layout

\begin_layout Itemize
Inner Attributes (#![inner_attribute]): Applied to the item they are contained
 within.
 They are often found at the beginning of source files or modules to configure
 or set options for the scope they reside in.
\end_layout

\begin_layout Section
Unsafe Rust
\begin_inset CommandInset label
LatexCommand label
name "sec:Unsafe-Rust"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Tell the compiler I know what I'm doing!
\end_layout

\begin_layout Standard
The unsafe keyword allows you to bypass the language's usual safety checks
 and guarantees.
 It's used when you need to perform operations that the Rust compiler can't
 prove to be safe at compile-time, such as accessing raw pointers, dereferencing
 them, or making changes to mutable static variables.
 It's a way to tell the Rust compiler that you, the programmer, will ensure
 the safety of the code within the unsafe block.
\end_layout

\begin_layout Section
Module
\begin_inset CommandInset label
LatexCommand label
name "sec:Module"

\end_inset


\end_layout

\begin_layout Standard
In a Rust project, you can import this module using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mod vga;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It tells the compiler to load a module named vga.
 This means the compiler will search for a file named vga.rs in the current
 directory.
 And allowing you to use the functionality and variables provided by that
 module in the current scope.
\end_layout

\begin_layout Standard
For example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start() {
\end_layout

\begin_layout Plain Layout

    // vga::test_print();
\end_layout

\begin_layout Plain Layout

    vga::test_rolldown();
\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can use test_rolldown() function that declare in vga.rs file.
\end_layout

\begin_layout Section
Structs
\begin_inset CommandInset label
LatexCommand label
name "sec:Structs"

\end_inset


\end_layout

\begin_layout Standard
A struct, short for structure, is a custom data type that lets you package
 together related data under a single name.
 We use it to making code more organized, readable, and maintainable.
 It's similar to structs in C.
 In our case
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

struct VGAChar {
\end_layout

\begin_layout Plain Layout

    ascii: u8,
\end_layout

\begin_layout Plain Layout

    color: u8,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
VGAChar is a struct with 2 fields, ascii and color both with data type u8.
 
\end_layout

\begin_layout Standard
We can create instance by
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

let character = VGAChar {
\end_layout

\begin_layout Plain Layout

        ascii: b'A', // ASCII code for 'A'
\end_layout

\begin_layout Plain Layout

        color: 0x04; // black background, red foreground
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using character.ascii and character.color access the ascii and color fields
 of the character instance, respectively.
 You can use these to read (and, if mutable, modify) the data stored in
 an instance of a struct.
\end_layout

\begin_layout Section
Impl
\begin_inset CommandInset label
LatexCommand label
name "subsec:Impl"

\end_inset


\end_layout

\begin_layout Standard
It is a keyword used to implement functionality for a particular type, such
 as a struct or enum.
 It allows you to define methods, associated functions, and trait implementation
s for the specified type.
 The impl keyword can be used indefinitely, but typically, organizing related
 functionality into one or a few impl blocks is a clearer and more maintainable
 practice.
\end_layout

\begin_layout Section
Function
\begin_inset CommandInset label
LatexCommand label
name "sec:Function"

\end_inset


\end_layout

\begin_layout Standard
The most important function in Rust is main, which is the entry point of
 many programs.
 But in our case the thing is a bit different, we don't have a standard
 main function since we are doing the system development.
 In lab1-1 it is using _start().
 We use the panic as example to explain every part of function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

fn panic(_info: &core::panic::PanicInfo) -> ! {
\end_layout

\begin_layout Plain Layout

    // the `!` type means "this function never returns"
\end_layout

\begin_layout Plain Layout

    // place holder for now, we'll write this function later
\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
fn keyword
\series default
; In Rust, a function is defined using the fn keyword, followed by the function
 name (panic in this case)
\end_layout

\begin_layout Itemize

\series bold
function parameters; 
\series default
These are specified within parentheses if there is any (could be none) _info
 is a parameter of type &core::panic::PanicInfo
\end_layout

\begin_layout Itemize

\series bold
->
\series default
; indicates the return type of the function, ! means the function doesn't
 return a value
\end_layout

\begin_layout Section
Match
\begin_inset CommandInset label
LatexCommand label
name "sec:Match"

\end_inset


\end_layout

\begin_layout Standard
It allows you to compare a value against a series of patterns and execute
 code based on which pattern matches.
 It's similar to a switch statement in other languages but more powerful.
 For our example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

match byte {
\end_layout

\begin_layout Plain Layout

	// if not acceptable ASCII, print a space with error color
\end_layout

\begin_layout Plain Layout

	0x20..=0x7e | b'
\backslash
n' => self.write_byte(byte, COLOR),
\end_layout

\begin_layout Plain Layout

	_ => self.write_byte(b' ', ERROR_COLOR),
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
0x20..=0x7e | b'
\backslash
n': This is a pattern that matches any byte within the range 0x20 to 0x7e
 or the newline character b'
\backslash
n'.
 If the byte matches this pattern, self.write_byte(byte, COLOR) is executed.
 
\end_layout

\begin_layout Itemize
_: This is the wildcard pattern that matches any value that hasn't been
 matched by the previous patterns.
 Then self.write_byte(b' ', ERROR_COLOR) is executed, printing a space with
 error color.
\end_layout

\begin_layout Section
Declarative Macro
\begin_inset CommandInset label
LatexCommand label
name "sec:Declarative-Macro"

\end_inset


\end_layout

\begin_layout Standard
Rust macros typically end with an !, it allows you to write code that writes
 other code, which is known as metaprogramming.
 Or it can be understood as rules for replacing code during compilation.
 When called in the code, they match patterns and generate code based on
 those patterns.
 These macros are executed entirely under the control of the compiler during
 expansion, resulting in the generation of the required code at compile
 time, which is then executed at runtime.
 Because write! macro is not really straight forward, we use vec! as example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let v: Vec<u32> = vec![1, 2, 3];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[macro_export]
\end_layout

\begin_layout Plain Layout

macro_rules! vec {
\end_layout

\begin_layout Plain Layout

    ( $( $x:expr ),* ) => {
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            let mut temp_vec = Vec::new();
\end_layout

\begin_layout Plain Layout

            $(
\end_layout

\begin_layout Plain Layout

                temp_vec.push($x);
\end_layout

\begin_layout Plain Layout

            )*
\end_layout

\begin_layout Plain Layout

            temp_vec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will create a new vector, then push 1, 2, 3 into it.
\end_layout

\begin_layout Section
Trait
\begin_inset CommandInset label
LatexCommand label
name "sec:Trait"

\end_inset


\end_layout

\begin_layout Standard
In Rust, a trait defines a set of methods that types can implement.
 It allows for defining shared behavior across different types.
 It usually require programmer to provide a method, and then provide other
 method base on it.
 In our case, for Trait core::fmt::Write we provide write_str
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub trait Write {
\end_layout

\begin_layout Plain Layout

    // Required method
\end_layout

\begin_layout Plain Layout

    fn write_str(&mut self, s: &str) -> Result;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Provided methods
\end_layout

\begin_layout Plain Layout

    fn write_char(&mut self, c: char) -> Result { ...
 }
\end_layout

\begin_layout Plain Layout

    fn write_fmt(&mut self, args: Arguments<'_>) -> Result { ...
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then we could use macro write! and writeln! base on them.
\end_layout

\begin_layout Section
Self-study materials
\end_layout

\begin_layout Standard
However, to master this language, you'll need to continue learning as you
 go.
 Here are some recommended books and platforms for learning Rust:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Official Rust Website"
target "https://www.rust-lang.org/"
literal "false"

\end_inset

: The official Rust website provides comprehensive documentation, tutorials,
 and resources for learning Rust.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "The Rust Programming Language"
target "https://doc.rust-lang.org/book/"
literal "false"

\end_inset

: Affectionately nicknamed “the book,” The Rust Programming Language will
 give you an overview of the language from first principles
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Rust by Example"
target "https://doc.rust-lang.org/rust-by-example/"
literal "false"

\end_inset

: Rust by Example (RBE) is a collection of runnable examples that illustrate
 various Rust concepts and standard libraries.
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset

 If you prefer learning a new language by reading example code, then this
 book might be more suitable for you.
 
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "A half-hour to learn Rust"
target "https://fasterthanli.me/articles/a-half-hour-to-learn-rust"
literal "false"

\end_inset

: Providing lots of Rust snippets.
 It has brief explanation of each code snippet, suitable for quick browsing.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "rustlings"
target "https://rustlings.cool/"
literal "false"

\end_inset

: This project contains small exercises to get you used to reading and writing
 Rust code.
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"
literal "false"

\end_inset


\end_layout

\begin_layout Chapter
Lab 1 - Getting started
\end_layout

\begin_layout Section
Expected Outcome
\end_layout

\begin_layout Standard
In this Lab you would learn:
\end_layout

\begin_layout Itemize
How to create a Rust program in standalone mode
\end_layout

\begin_layout Itemize
Variable in Rust
\end_layout

\begin_layout Itemize
Function in Rust
\end_layout

\begin_layout Itemize
How bootloader works
\end_layout

\begin_layout Itemize
What is VGA buffer
\end_layout

\begin_layout Standard
In this lab, we'll create a Rust program entirely from scratch, free from
 any reliance on a host operating system.
 Our goal is to develop a minimal 64-bit kernel that can display text using
 VGA through QEMU.
 
\end_layout

\begin_layout Section
Preparation
\end_layout

\begin_layout Itemize
QEMU
\end_layout

\begin_layout Standard
To run the experiment's output, we need to use QEMU.
 Here, we won't list the installation steps for QEMU on various operating
 systems.
 Please visit the official website at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.qemu.org/download/
\end_layout

\end_inset

 to download the appropriate installer and follow the on-screen instructions
 for installation.
\end_layout

\begin_layout Standard
Windows users may need to manually add the QEMU directory to the Path variable.
 This can be done by searching 
\begin_inset Quotes eld
\end_inset

environment variable
\begin_inset Quotes erd
\end_inset

 in the control panel, opening 
\begin_inset Quotes eld
\end_inset

edit environment variables for your account
\begin_inset Quotes erd
\end_inset

, find 
\begin_inset Quotes eld
\end_inset

Path
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

, and add C:
\backslash
Program Files
\backslash
qemu to the list once you had QEMU properly installed.
\end_layout

\begin_layout Itemize
Nightly Rust
\end_layout

\begin_layout Standard
If you are not install Rust already, please follow instructions here 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Install-Rust"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rust offers various versions, but for operating system development, we require
 certain experimental features not available in the stable version.
 Thus, we can't use the stable version.
 To install Nightly Rust, simply enter the following command in your terminal.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup update nightly 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You will wish to confirm that your default version of Rust is the nightly
 verion by running
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustc --version 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
again.
 
\end_layout

\begin_layout Standard
If the output doesn't consist of 
\begin_inset Quotes eld
\end_inset

nightly
\begin_inset Quotes erd
\end_inset

, run:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup show 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which will show all versions of Rust currently installed.
 You can copy the shown name of the nightly version here, before using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup default <paste name here> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to set it as default.
\end_layout

\begin_layout Itemize
Suitable IDE
\end_layout

\begin_layout Standard
After installing Rust, choose a suitable IDE as the development environment,
 as introduced in Lab 0.
 Please follow instruction here
\series bold
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Integrated-Development-Environme"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Itemize
bootimage
\end_layout

\begin_layout Standard
This tool assists us in generating files for the virtual machine (QEMU).
 To install it, use the following command in your terminal using Cargo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo install bootimage
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
llvm-tools-preview
\end_layout

\begin_layout Standard
The llvm-tools-preview is a dependency for the bootimage tool.
 You can install it using command 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup component add llvm-tools-preview
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
rust-src
\end_layout

\begin_layout Standard
If error messages regarding to missing rust-src show up in compilation attempts,
 install it with the following command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup component add rust-src
\end_layout

\end_inset


\end_layout

\begin_layout Section
Task 1 - Standalone Rust Binary
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
When we create a Rust program, similar to Lab 0, it usually relies on an
 existing operating system.
 Rust comes with a standard library that depends on the features of that
 operating system.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-14 23-37-02.png
	width 60page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Common Rust Program
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
But since our goal is to build an operating system from the ground up, we
 can't rely on the existing one.
 So, we disable the standard library using no_std, and this lets us work
 directly with hardware.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-15 00-04-29.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Standalone Rust
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
See branch lab-1-1 for the code.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Setup a New Rust Project
\end_layout

\begin_layout Standard
Open a terminal and create a new Rust project by running
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,fontsize={\small},breaklines=true,showspaces=true"
inline false
status open

\begin_layout Plain Layout

cargo new chronos_lab --bin --edition 2018
\end_layout

\end_inset

This creates a new binary project named chronos_lab.
 You could use your own name.
 Change into the project directory with 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd <your project name>
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Editing Cargo.toml
\end_layout

\begin_layout Standard
Open the Cargo.toml file in your project's root directory.
\end_layout

\begin_layout Standard
In the initial Cargo.toml file, the [package] section includes predefined
 name, version, and edition information.
 You can now leave them unchanged.
\end_layout

\begin_layout Standard
Add configurations for development and release profiles to change the panic
 strategy to abort, which disables stack unwinding during a panic.
 Add these lines at the end of the Cargo.toml file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[profile.dev] 
\end_layout

\begin_layout Plain Layout

panic = "abort"  # Configures the compiler to abort the program on panic
 during development builds.
\end_layout

\begin_layout Plain Layout

[profile.release] 
\end_layout

\begin_layout Plain Layout

panic = "abort"  # Configures the compiler to abort the program on panic
 during release builds.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the detail explaination of this part:
\end_layout

\begin_layout Itemize
[profile.dev] and [profile.release]: These sections allow you to specify settings
 for development (cargo build) and release (cargo build --release) profiles,
 respectively.
 
\end_layout

\begin_layout Itemize
panic = "abort": By default, Rust tries to recover from errors (panics)
 by unwinding the program's stack, which can't be done without additional
 support.
 In this case, we want the program to just stop immediately when an error
 happens.
 Setting panic = "abort" makes the program do that.
 
\end_layout

\begin_layout Standard

\series bold
Step 3: Writing the Freestanding Rust Code
\end_layout

\begin_layout Standard
Open the src/main.rs file.
 Replace its contents with the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

#![no_std]  // disable the Rust standard library
\end_layout

\begin_layout Plain Layout

#![no_main] // disable all Rust-level entry points
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start() -> ! {
\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[panic_handler]    // this function is called on panic
\end_layout

\begin_layout Plain Layout

fn panic(_info: &core::panic::PanicInfo) -> ! {
\end_layout

\begin_layout Plain Layout

    // the `!` type means "this function never returns"
\end_layout

\begin_layout Plain Layout

    // place holder for now, we'll write this function later
\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the detail explaination of this part:
\end_layout

\begin_layout Itemize
#![no_std]: This attribute disables the standard library.
 It is used for low-level programming, where direct control over the system
 is required.
 
\end_layout

\begin_layout Itemize
#![no_main]: Rust programs typically start execution from the main function.
 This attribute disables it, which is necessary for creating a freestanding
 binary.
 
\end_layout

\begin_layout Itemize
#[no_mangle]: This attribute prevents Rust from changing the name of the
 _start function, ensuring the linker can find it.
 
\end_layout

\begin_layout Itemize
pub extern "C" fn _start() -> !: Defines the entry point for our program.
 The function will use the C calling convention.
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Calling-convention"
plural "false"
caps "false"
noprefix "false"

\end_inset

 The ! return type indicates that this function will never return.
 
\end_layout

\begin_layout Itemize
#[panic_handler]: Specifies the function to call when a panic occurs.
 Panics can occur for various reasons, such as out-of-bounds array access.
\end_layout

\begin_layout Standard
For more information see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Attributes"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 5: Building the Project
\end_layout

\begin_layout Standard
By default, the linker includes the C runtime, which can lead to errors.
 To avoid this problem, we have two options.
 One way is to pass different parameters based on the operating system we're
 using.
 However, a more direct approach is to specify that we're compiling for
 an embedded system.
 This way, the linker won't attempt to link the C runtime environment, ensuring
 a successful build without linker errors.
\end_layout

\begin_layout Standard
First add the target architecture.
 Open your terminal run the command 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rustup target add thumbv6m-none-eabi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This command uses rustup, the Rust toolchain installer, to add support for
 compiling Rust code for the thumbv6m-none-eabi target, which is a common
 architecture for ARM Cortex-M microcontrollers.
 You can also choose alternative targets as long as the underlying environment
 doesn't include an operating system.
\end_layout

\begin_layout Standard
Execute 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo build --target=thumbv6m-none-eabi
\end_layout

\end_inset

 to compile your project for the thumbv6m-none-eabi target.
 This tells Cargo, Rust's package manager and build system, to compile the
 project for the specified architecture rather than the default target platform
 that is your host machine.
 
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
At this point, the program won't produce any output.
 If all the steps proceed smoothly, it should compile successfully without
 reporting any errors.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo build --target=thumbv6m-none-eabi
\end_layout

\begin_layout Plain Layout

   Compiling chronos_labs v0.1.0 (/home/lucia/2023cse/project/chronos_labs)
\end_layout

\begin_layout Plain Layout

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
\end_layout

\end_inset


\end_layout

\begin_layout Section
Task 2 - Build Minimal Kernel 
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
We'll use Rust to create a small 64-bit kernel for the x86 architecture
 base on program we made for previous task.
 We will use the bootloader tool to create a bootable disk image, allowing
 us to launch it using QEMU.
 
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Create a custom target specification file
\end_layout

\begin_layout Standard
In the previous task, we referenced an embedded environment as our compilation
 target.
 However, to build our custom operating system, we need to write a custom
 target specification file.
 Create a chronos_labs.json file in the root directory, although you can
 choose any name for this file.
 Create this file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

touch chronos_labs.json
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Do mind that the command 
\begin_inset Quotes eld
\end_inset

touch
\begin_inset Quotes erd
\end_inset

 doesn't work for Windows CMD / PowerShell.
 Windows users will need to create the json file in other ways.
\end_layout

\begin_layout Standard
Here is the content of the file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  "llvm-target": "x86_64-unknown-none",
\end_layout

\begin_layout Plain Layout

  "data-layout": "e-m:e-i64:64-f80:128-n8:16:32:64-S128",
\end_layout

\begin_layout Plain Layout

  "arch": "x86_64",
\end_layout

\begin_layout Plain Layout

  "target-endian": "little",
\end_layout

\begin_layout Plain Layout

  "target-pointer-width": "64",
\end_layout

\begin_layout Plain Layout

  "target-c-int-width": "32",
\end_layout

\begin_layout Plain Layout

  "os": "none",
\end_layout

\begin_layout Plain Layout

  "executables": true,
\end_layout

\begin_layout Plain Layout

  "linker-flavor": "ld.lld",
\end_layout

\begin_layout Plain Layout

  "linker": "rust-lld",
\end_layout

\begin_layout Plain Layout

  "panic-strategy": "abort",
\end_layout

\begin_layout Plain Layout

  "disable-redzone": true,
\end_layout

\begin_layout Plain Layout

  "features": "-mmx,-sse,+soft-float"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You don't necessarily need to understand what each fields represents, but
 here are a few of the parameters that are more unique compared to other
 operating systems and might be worth understanding:
\end_layout

\begin_layout Itemize
"llvm-target": "x86_64-unknown-none": Specifies the target architecture
 for the compiler.
 Here, it's for 64-bit x86 architecture without a specific vendor or operating
 system.
\end_layout

\begin_layout Itemize
"arch": "x86_64": The architecture of the target system, indicating a 64-bit
 processor.
\end_layout

\begin_layout Itemize
"linker-flavor": "ld.lld" and "linker": "rust-lld": Specify which linker
 to use, here it's cross-platform LLD linker included with Rust.
\end_layout

\begin_layout Itemize
"panic-strategy": "abort": Determines how to handle panic situations.
 "abort" means the program will immediately stop, without trying to unwind
 the stack.
\end_layout

\begin_layout Itemize
"disable-redzone": true: Disables the red zone, or sometimes it could lead
 to stack corruption.o
\end_layout

\begin_layout Itemize
"features": "-mmx,-sse,+soft-float": Specifies CPU features to enable or
 disable.
 Here, MMX and SSE are disabled, while software-based floating-point calculation
s are enabled.
 Disable of mmx and sse features means we disable the Single Instruction
 Multiple Data (SIMD) instructions because it will cause interruption too
 frequently.
 And enable soft-float that simulates all floating-point operations using
 software functions that rely on regular integers will solve the error by
 disable SIMD.
\end_layout

\begin_layout Standard
If you meet an error message saying 
\begin_inset Quotes eld
\end_inset

data layout differs
\begin_inset Quotes erd
\end_inset

 during your compilation attempt, edit value of item 
\begin_inset Quotes eld
\end_inset

data-layout
\begin_inset Quotes erd
\end_inset

 in this file, to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128
"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may also need to edit the corresponding value in file x86_64-bootloader.json
 in bootloader's installation directory to this value above, if another
 
\begin_inset Quotes eld
\end_inset

data layout differs
\begin_inset Quotes erd
\end_inset

 error shows up with only chronos_labs.json edited.
\end_layout

\begin_layout Standard

\series bold
Step 2: Create .cargo/config.toml
\end_layout

\begin_layout Standard
In your project's root directory, create a folder named .cargo
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mkdir .cargo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside the .cargo folder, create a file named config.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd .cargo && touch config.toml
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Replace 
\begin_inset Quotes eld
\end_inset

&&
\begin_inset Quotes erd
\end_inset

 in the command with 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

, if you are using PowerShell.
\end_layout

\begin_layout Standard
Open config.toml and paste the following contents:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[unstable]
\end_layout

\begin_layout Plain Layout

build-std = ["core", "compiler_builtins"]
\end_layout

\begin_layout Plain Layout

build-std-features = ["compiler-builtins-mem"]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[build]
\end_layout

\begin_layout Plain Layout

target = "chronos_labs.json"	#replace with your file name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here are explanations for each lines:
\end_layout

\begin_layout Standard

\series bold
[unstable]
\end_layout

\begin_layout Standard
build-std = ["core", "compiler_builtins"]: Tells Cargo to compile essential
 Rust libraries core and compiler_builtins from scratch
\end_layout

\begin_layout Standard
build-std-features = ["compiler-builtins-mem"]: Activates memory functions
 in compiler_builtins
\end_layout

\begin_layout Standard

\series bold
[build] 
\end_layout

\begin_layout Standard
target = "chronos_labs.json": Points to a custom target file to specify how
 to compile for a particular setup.
\end_layout

\begin_layout Standard

\series bold
Step 3: Use bootimage
\end_layout

\begin_layout Standard
Add bootimage to dependency, open Cargo.toml and add under [dependencies]
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies]
\end_layout

\begin_layout Plain Layout

bootloader = "0.9.23"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also add these in .cargo/config.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[target.'cfg(target_os = "none")']
\end_layout

\begin_layout Plain Layout

runner = "bootimage runner"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
[target.'cfg(target_os = "none")'] include "chronos_labs.json" file, and runner
 key defines command gets executed bootimage runner after the project has
 been successfully compiled.
\end_layout

\begin_layout Standard
Now we can use cargo run to execute this project.
 The cargo run command is a convenient tool used in Rust projects to compile
 and run the application code in one step.
 
\end_layout

\begin_layout Standard
If you interested in what did bootimage tool do, see
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:What-did-bootimage"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
Reminder: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo run
\end_layout

\end_inset

 is used instead of 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo build --target=thumbv6m-none-eabi
\end_layout

\end_inset

starting from this task.
 Please use cargo run to get the output.
\end_layout

\begin_layout Standard
The output should be a blank QEMU window:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-28 22-55-22.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 3 - Show something!
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
We use VGA text buffer to make output for this operating system.
 It is because it's simple and straightforward to write to.
 VGA text mode provides a direct way to display text on the screen by writing
 characters and their attributes (like color) to a specific area of memory.
 More inforamtion about it 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VGA-text-buffer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In the Windows operating system, encountering an error often results in
 the appearance of a blue screen.
 Therefore, we will also attempt to display a blue screen in our system.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
Open src/main.rs
\end_layout

\begin_layout Standard

\series bold
Step 1: Define Constants
\end_layout

\begin_layout Standard
Add these constant
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

const BUFFER_HEIGHT: usize = 25;
\end_layout

\begin_layout Plain Layout

const BUFFER_WIDTH: usize = 80;
\end_layout

\begin_layout Plain Layout

const BACKGROUND_COLOR: u16 = 0x1000; // blue background, black foreground
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
const BUFFER_HEIGHT: usize = 25; Defines a constant named BUFFER_HEIGHT
 with a type of usize (an unsigned size type, which means it's a number
 that can't be negative and its size varies based on the computer architecture).
 The value 25 represents the number of text lines that the VGA text buffer
 can display at one time.
 
\end_layout

\begin_layout Itemize
const BUFFER_WIDTH: usize = 80; Similar to the first line, this defines
 a constant named BUFFER_WIDTH, also of type usize.
 The value 80 represents the number of characters that can fit on a single
 line of the VGA text buffer.
 
\end_layout

\begin_layout Itemize
const BACKGROUND_COLOR: u16 = 0x1000; This line defines a constant named
 BACKGROUND_COLOR with a type of u16 (a 16-bit unsigned integer).
 The value 0x1000 is a hexadecimal number that specifies the color attributes
 for the text and background.
 It will be 000100000000 in binary.
 Recover from 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VGA-text-buffer"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we know that it sets the background color to blue and the foreground (text)
 color to black.
 
\end_layout

\begin_layout Standard
See more about variables in Rust on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Variables"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Initializes Buffer
\end_layout

\begin_layout Standard
Add this line inside _start()
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

 let vga_buffer = unsafe { core::slice::from_raw_parts_mut(0xb8000 as *mut
 u16, 2000) }; 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
unsafe { ...
 }: In Rust, unsafe blocks are used for performing unsafe operations, such
 as direct hardware access or low-level memory operations.
 Here, the unsafe block is used for operations related to hardware interaction.
\end_layout

\begin_layout Itemize
core::slice::from_raw_parts_mut(0xb8000 as *mut u16, 2000): This is a function
 call that creates a mutable slice
\end_layout

\begin_layout Standard
- 0xb8000 as *mut u16: This is a memory address conversion, casting the
 hexadecimal address 0xb8000 as a mutable pointer to a u16 type.
 0xb8000 is starting address of VGA buffer, and each element is a 16-bit
 character/color combination.
\begin_inset Newline newline
\end_inset

- 2000: This is the length of the slice, indicating that the slice contains
 2000 u16 elements.
 That's the size of VGA buffer by 80*25 = 2000
\end_layout

\begin_layout Standard

\series bold
Step 3: Assign values
\end_layout

\begin_layout Standard
Add a for loop below
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

for i in 0..(BUFFER_HEIGHT * BUFFER_WIDTH) {
\end_layout

\begin_layout Plain Layout

        vga_buffer[i] = BACKGROUND_COLOR;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sets each element of the vga_buffer array to BACKGROUND_COLOR.
 In this case, leave character section empty.
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-29 13-53-17.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
You may try to display other color than blue by yourself? You could find
 the color code from 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://wiki.osdev.org/Printing_To_Screen
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Lab 2 - VGA output
\end_layout

\begin_layout Section
Expected Outcome
\end_layout

\begin_layout Standard
This lab is relating to the output operation in OS, it will show the things
 on screen.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-06 00-00-54.png
	width 70page%

\end_inset


\end_layout

\begin_layout Standard
In this lab, we'll implement support of safety output string, number and
 support Rust’s formatting macros instead of write on buffer directly.
 In this process, we will use traits to implement more functionality with
 less, cleaner, and more concise code.
 We will establish an interface that ensures safety and simplicity by isolating
 all unsafe operations within a dedicated module.
\begin_inset Newline newline
\end_inset

You will implement the section of the operating system that manages output.
\end_layout

\begin_layout Section
Task 1 - Print text at a specified position using ASCII encoding
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
At the end of lab 1, we traversed the entire VGA buffer to output a blue
 screen.
 Now we will continue to use slices to output specific text at specified
 positions.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Modify the BACKGROUND_COLOR constant
\end_layout

\begin_layout Standard
In the previous implementation, we used the u16 data type for assignment
 because we didn't need to output specific characters.
 However, this time we will only define the color part.
 If you forget how to define it, you can refer to the documentation.
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VGA-text-buffer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Change constant name into COLOR 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

const COLOR: u8 = 0x04; // black background, red foreground
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You could change into different value to represent different color as you
 wish! See the reference on 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://wiki.osdev.org/Printing_To_Screen
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Modify vga_buffer
\end_layout

\begin_layout Standard
We change pointer datatype from u16 to u8 because we want to assign character
 and color seperately.
 Length change to 4000 so the end of buffer remain unchanged.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

let vga_buffer = unsafe { core::slice::from_raw_parts_mut(0xb8000 as *mut
 u8, 4000) }; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Print character
\end_layout

\begin_layout Standard
Delete the for loop under buffer definition and change into
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

    vga_buffer[0] = b'H';
\end_layout

\begin_layout Plain Layout

    vga_buffer[1] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[2] = b'e';
\end_layout

\begin_layout Plain Layout

    vga_buffer[3] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[4] = b'l';
\end_layout

\begin_layout Plain Layout

    vga_buffer[5] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[6] = b'l';
\end_layout

\begin_layout Plain Layout

    vga_buffer[7] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[8] = b'o';
\end_layout

\begin_layout Plain Layout

    vga_buffer[9] = COLOR;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
b'H': It represents a byte literal(a single byte of data).
 In this case, corresponds to the ASCII encoding of the uppercase letter
 'H'.
\end_layout

\begin_layout Itemize
COLOR: Color part of the character, represent red foreground and black backgroun
d.
\end_layout

\begin_layout Standard
Remember to keep 
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

    loop {} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Don't delete it!
\end_layout

\begin_layout Standard
You would see the output like this if everything going well
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-07 19-19-19.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 4: Print somewhere else
\end_layout

\begin_layout Standard
Remember that
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

const BUFFER_HEIGHT: usize = 25;
\end_layout

\begin_layout Plain Layout

const BUFFER_WIDTH: usize = 80;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can print words at the new line
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

// write "World" at the next line
\end_layout

\begin_layout Plain Layout

    vga_buffer[160] = b'W';
\end_layout

\begin_layout Plain Layout

    vga_buffer[161] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[162] = b'o';
\end_layout

\begin_layout Plain Layout

    vga_buffer[163] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[164] = b'r';
\end_layout

\begin_layout Plain Layout

    vga_buffer[165] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[166] = b'l';
\end_layout

\begin_layout Plain Layout

    vga_buffer[167] = COLOR;
\end_layout

\begin_layout Plain Layout

    vga_buffer[168] = b'd';
\end_layout

\begin_layout Plain Layout

    vga_buffer[169] = COLOR;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or at the end
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

    // End
\end_layout

\begin_layout Plain Layout

    vga_buffer[3998] = b'!';
\end_layout

\begin_layout Plain Layout

    vga_buffer[3999] = COLOR;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now you can visually see the correspondence between memory addresses and
 screen positions.
 
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
The code may look cumbersome, but it's okay because it's just to demonstrate
 the correspondence between the VGA buffer and the screen.
 We'll implement the print! and println! functions in a more elegant way.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-07 18-47-50.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 2 - Write byte
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this task, we will create a vga.rs file to handle VGA output specifically,
 aiming to improve code readability.
 At the same time, we'll use a more elegant approach to output single characters
, recognize newline characters, and handle situations where characters exceed
 the screen.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Create src/vga.rs file
\end_layout

\begin_layout Standard
Create a vga.rs file in the src folder, and copy the necessary declarations.
 We will import this file as module to main.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

const BUFFER_HEIGHT: usize = 25;
\end_layout

\begin_layout Plain Layout

const BUFFER_WIDTH: usize = 80;
\end_layout

\begin_layout Plain Layout

const COLOR: u8 = 0x04; // black background, red foreground
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Create a new struct represent single VGA character
\end_layout

\begin_layout Standard
We create VGAChar that contain both ASCII and color.
 And in Rust, the ordering of fields in default structs is not defined,
 so we use the repr(C) attribute to ensure that the struct's fields are
 laid out in memory exactly in order.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

#[repr(C)]
\end_layout

\begin_layout Plain Layout

#[derive(Clone, Copy)]
\end_layout

\begin_layout Plain Layout

struct VGAChar {
\end_layout

\begin_layout Plain Layout

    ascii: u8,
\end_layout

\begin_layout Plain Layout

    color: u8,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More about struct see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Structs"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
It also relate to the big endian and little endian that define in
\series bold
 
\series default
specification file 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Big-endian-and"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Itemize
#[derive(Clone, Copy)]: Generates code to implement the Clone and Copy for
 that type, needed by volatile.
\end_layout

\begin_layout Standard

\series bold
Step 3: Struct for buffer
\end_layout

\begin_layout Standard
We use the volatile library, which helps us prevent Rust's compiler from
 optimizing out our write operations to the buffer.
\end_layout

\begin_layout Standard
Add support in Cargo.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies]
\end_layout

\begin_layout Plain Layout

bootloader = "0.9.23"
\end_layout

\begin_layout Plain Layout

volatile = "0.2.6"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Add these lines under VGAChar
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#[repr(transparent)]
\end_layout

\begin_layout Plain Layout

struct Buffer {
\end_layout

\begin_layout Plain Layout

    chars: [[Volatile<VGAChar>; BUFFER_WIDTH]; BUFFER_HEIGHT], // 2D array
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use a 2D array to represent rows and columns.
\end_layout

\begin_layout Itemize
#[repr(transparent)]: Buffer has the same memory layout as its inner 2D
 array of Volatile<VGAChar> elements
\end_layout

\begin_layout Standard

\series bold
Step 4: Implement Writer
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

pub struct Writer {
\end_layout

\begin_layout Plain Layout

    column_position: usize,
\end_layout

\begin_layout Plain Layout

    row_position: usize,
\end_layout

\begin_layout Plain Layout

    buffer: &'static mut Buffer,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For line buffer: &'static mut Buffer
\end_layout

\begin_layout Standard
It is a field named buffer, is a mutable reference to a Buffer instance.
\end_layout

\begin_layout Itemize
& denotes a reference
\end_layout

\begin_layout Itemize
'static is a lifetime specifier.
 When used in a context like this, it indicates that the reference can live
 for the entire duration of the program.
 
\end_layout

\begin_layout Itemize
mut means it allows modification of the Buffer instance it refers to
\end_layout

\begin_layout Standard
We use writer to implement output function.The first character will appear
 in the top-left corner.
 When a row is filled or a newline character is entered, input will move
 to the next row.
 If the entire screen is filled, all input will shift up one row, clearing
 the initial first row of input.
 To achieve this, we need to keep track of the current input position, namely
 the row and column numbers.
\end_layout

\begin_layout Standard
This is the write_byte function that can output single character
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

impl Writer {
\end_layout

\begin_layout Plain Layout

    pub fn write_byte(&mut self, byte: u8, color: u8) {
\end_layout

\begin_layout Plain Layout

        match byte {
\end_layout

\begin_layout Plain Layout

            b'
\backslash
n' => self.new_line(),
\end_layout

\begin_layout Plain Layout

            byte => {
\end_layout

\begin_layout Plain Layout

                if self.column_position >= BUFFER_WIDTH {
\end_layout

\begin_layout Plain Layout

                    self.new_line();
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                let row = self.row_position;
\end_layout

\begin_layout Plain Layout

                let col = self.column_position;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                self.buffer.chars[row][col].write(VGAChar {
\end_layout

\begin_layout Plain Layout

                    ascii: byte,
\end_layout

\begin_layout Plain Layout

                    color,
\end_layout

\begin_layout Plain Layout

                });
\end_layout

\begin_layout Plain Layout

                self.column_position += 1;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can find more information about `impl` here.
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Impl"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
In the next step, we will implement the new_line function.
\end_layout

\begin_layout Standard
We use the write method from the volatile library to write code at the correspon
ding position (therefore Buffer is with the mut parameter).
 The color is then a shorthand for color: color, which can be omitted when
 the variable name matches the field name.
\end_layout

\begin_layout Standard
After written into each character, we plus the column_position.
\end_layout

\begin_layout Standard

\series bold
Step 5: new_line() function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

impl Writer {
\end_layout

\begin_layout Plain Layout

    pub fn new_line(&mut self) {
\end_layout

\begin_layout Plain Layout

        if self.row_position < BUFFER_HEIGHT - 1 {
\end_layout

\begin_layout Plain Layout

            self.column_position = 0;
\end_layout

\begin_layout Plain Layout

            self.row_position += 1; // change to new line
\end_layout

\begin_layout Plain Layout

        } else {    // if the row is full, scroll up
\end_layout

\begin_layout Plain Layout

            for row in 1..BUFFER_HEIGHT {
\end_layout

\begin_layout Plain Layout

                for col in 0..BUFFER_WIDTH {
\end_layout

\begin_layout Plain Layout

                    let character = self.buffer.chars[row][col].read();
\end_layout

\begin_layout Plain Layout

                    self.buffer.chars[row - 1][col].write(character);
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            self.clear_row(BUFFER_HEIGHT - 1);
\end_layout

\begin_layout Plain Layout

            self.column_position = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fn clear_row(&mut self, row: usize) { // new function to clear a row
\end_layout

\begin_layout Plain Layout

        for col in 0..BUFFER_WIDTH {
\end_layout

\begin_layout Plain Layout

            self.buffer.chars[row][col].write(VGAChar {
\end_layout

\begin_layout Plain Layout

                ascii: b' ',
\end_layout

\begin_layout Plain Layout

                color: COLOR,
\end_layout

\begin_layout Plain Layout

            });
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A new impl blocks is used to keep clearer and more maintainable codes, you
 can merge these two functions into previous block if you wish.
 
\end_layout

\begin_layout Standard
The new_line function is a used to move the next character to the start
 of the next line.
 If the character is already on the last line of the screen, it scrolls
 the screen up by one line by reading and write each character one line
 above.
 And clearing the last line by writing space to each character.
 The clear_row function is private function meaning it can only be accessed
 within its own module.
\end_layout

\begin_layout Standard

\series bold
Testing
\end_layout

\begin_layout Standard
Here is 2 testing function.
 Write in src/vga.rs
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

pub fn test_print() {
\end_layout

\begin_layout Plain Layout

    let mut writer = Writer {
\end_layout

\begin_layout Plain Layout

        column_position: 0,
\end_layout

\begin_layout Plain Layout

        row_position: 0,
\end_layout

\begin_layout Plain Layout

        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    writer.write_byte(b'H', COLOR);
\end_layout

\begin_layout Plain Layout

    writer.write_byte(b'
\backslash
n', COLOR);
\end_layout

\begin_layout Plain Layout

    writer.write_byte(b'e', COLOR);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pub fn test_rolldown() {
\end_layout

\begin_layout Plain Layout

    let mut writer = Writer {
\end_layout

\begin_layout Plain Layout

        column_position: 0,
\end_layout

\begin_layout Plain Layout

        row_position: 0,
\end_layout

\begin_layout Plain Layout

        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in 1..= 25 {
\end_layout

\begin_layout Plain Layout

        let line: u8 = i + b'0';
\end_layout

\begin_layout Plain Layout

        writer.write_byte(line, COLOR);
\end_layout

\begin_layout Plain Layout

        writer.write_byte(b'
\backslash
n', COLOR);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We creates an instance of the Writer struct, and test the basic function.
 To use these, goto main.rs
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

mod vga;    // import the `vga` module
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start() {
\end_layout

\begin_layout Plain Layout

    // vga::test_print();
\end_layout

\begin_layout Plain Layout

    vga::test_rolldown();
\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More about module?
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Module"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
We have 2 test functions, remember to run them one by one!
\end_layout

\begin_layout Standard
For the vga::test_print(); we have
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-07 23-22-05.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
This indicates that both the input bytes and the newline character functionality
 are working correctly.
\end_layout

\begin_layout Standard
And for vga::test_rolldown(); we have
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-07 23-24-02.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
The result is normal because we sequentially output the subsequent content
 of the ASCII table.
 We can see that the '1' that should have been outputted in the first row
 disappears and is replaced by '2'.
 This indicates that the functionality of shifting the other content upwards
 when the row limit is exceeded is working correctly.
\end_layout

\begin_layout Section
Task 3 - Enable write! and writeln!
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this section, we will extend the write_byte function to write_string,
 using it to output strings.
 Furthermore, we will use Rust's trait functionality to achieve formatted
 output.
\end_layout

\begin_layout Standard
What is write! and writeln! ? They are called declarative macro
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Declarative-Macro"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: write_string function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

impl Writer {
\end_layout

\begin_layout Plain Layout

    pub fn write_string(&mut self, s: &str) {
\end_layout

\begin_layout Plain Layout

        for byte in s.bytes() {
\end_layout

\begin_layout Plain Layout

            match byte {
\end_layout

\begin_layout Plain Layout

                // if not acceptable ASCII, print a space with error color
\end_layout

\begin_layout Plain Layout

                0x20..=0x7e | b'
\backslash
n' => self.write_byte(byte, COLOR),
\end_layout

\begin_layout Plain Layout

                _ => self.write_byte(b' ', ERROR_COLOR),
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's a loop that iterates over each byte in the string s.
 For each byte it calls write_byte to writes the byte to VGA buffer after
 validation.
 That is because not all UTF-8 encodings are supported by VGA; it only supports
 ASCII and the encodings defined in Code page 437
\begin_inset CommandInset citation
LatexCommand cite
key "key-5"
literal "false"

\end_inset

.
 Therefore, if a character (such as a Chinese character) cannot be displayed,
 we will output a blue block as a substitute.
 You can also choose your own error output.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/lucia/Downloads/Codepage-437.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Code page 437
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can learn more about match here
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Match"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Implement trait
\end_layout

\begin_layout Standard
Trait has many use cases, but we won't delve into all of them now.
 According to the documentation
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"
literal "false"

\end_inset

, after implementing fn write_str(&mut self, s: &str) -> Result, the trait
 can provide us with various functionalities like formatting output.
\end_layout

\begin_layout Standard
We just need to substitute the previously implemented write_string function,
 ensuring that the name write_str remains unchanged.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

impl core::fmt::Write for Writer {
\end_layout

\begin_layout Plain Layout

    fn write_str(&mut self, s: &str) -> core::fmt::Result {
\end_layout

\begin_layout Plain Layout

        self.write_string(s);
\end_layout

\begin_layout Plain Layout

        Ok(())
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
core::fmt::Result: It is an enum with two value, Ok and Err represents the
 result of a formatting operation.
 
\end_layout

\begin_layout Itemize
Ok(()): It means that the operation was successful, but there is no specific
 value to return, so it returns the unit value ().
\end_layout

\begin_layout Standard
You can learn more about trait here
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Trait"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Public Buffer and writer
\end_layout

\begin_layout Standard
Because we need to define Writer in main.rs, we have to make Buffer and Writer
 visible.
 This is a somewhat unsafe operation, but for now, let's proceed with this
 to complete the testing.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#[repr(transparent)]
\end_layout

\begin_layout Plain Layout

pub struct Buffer {
\end_layout

\begin_layout Plain Layout

    chars: [[Volatile<VGAChar>; BUFFER_WIDTH]; BUFFER_HEIGHT], // 2D array
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pub struct Writer {
\end_layout

\begin_layout Plain Layout

    pub column_position: usize,
\end_layout

\begin_layout Plain Layout

    pub row_position: usize,
\end_layout

\begin_layout Plain Layout

    pub buffer: &'static mut Buffer,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pub: It allows the item to be visible and it can be accessed and used outside
 of its module.
\end_layout

\begin_layout Standard

\series bold
Step 4: Create lib.rs
\end_layout

\begin_layout Standard
Using lib.rs to import all modules is standard practice within Rust community.
 We organizing all module imports in one place for clarity and consistency
 in the project structure.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#![no_std]
\end_layout

\begin_layout Plain Layout

pub mod vga;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Test
\end_layout

\begin_layout Standard
In main file, using 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use chronos_labs::vga::Writer;
\end_layout

\begin_layout Plain Layout

use chronos_labs::vga::Buffer;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mod vga;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To directly access to these two structure.
 Remember replace the chronos_labs if you using other name.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-17 14-50-07.png
	width 60page%

\end_inset


\end_layout

\begin_layout Itemize
unwrap(): This is used to simplify code when handling Result types.
 We could use this becuase we are confident that the result will always
 be Ok().
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
We can see the format is working so we could insert variable into string.
 Each chinese character using 3 bytes, so 6 blue boxes is printed in total.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-13 00-27-57.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 4 - Writer in vga.rs
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
We can directly create a Writer instance inside the vga module and access
 it by use.
 By instantiating Writer within vga instead of _start(), this encapsulation
 ensures cleaner and safer code.
 It also facilitates future calls to the Writer.
 
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add dependency
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies]
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

spin = "0.5.2"
\end_layout

\begin_layout Plain Layout

lazy_static = { version = "1.0", features = ["spin_no_std"] }
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
lazy_static: This crate in Rust provides a convenient way to define lazily
 initialized static variables.
 In our case is a writer instance that would be available throughout the
 entire program execution.
\end_layout

\begin_layout Itemize
spin: Add support of a mutex lock.
 
\end_layout

\begin_layout Standard

\series bold
Step 2: Initialize static WRITER
\end_layout

\begin_layout Standard
Add these below struct writer
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lazy_static!{
\end_layout

\begin_layout Plain Layout

    pub static ref WRITER: Mutex<Writer> = Mutex::new(Writer {
\end_layout

\begin_layout Plain Layout

        column_position: 0,
\end_layout

\begin_layout Plain Layout

        row_position: 0,
\end_layout

\begin_layout Plain Layout

        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
\end_layout

\begin_layout Plain Layout

    });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mutex<Writer>: It represents a mutex lock where the data type protected
 inside the lock is Writer.
\end_layout

\begin_layout Standard
Why we are using mutex lock? Because we want to make WRITER changable during
 program (write into buffer).
 So we only allow one process modify the writer at each time.
\end_layout

\begin_layout Standard

\series bold
Step 3: Change visibility
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#[repr(transparent)]
\end_layout

\begin_layout Plain Layout

struct Buffer {
\end_layout

\begin_layout Plain Layout

    chars: [[Volatile<VGAChar>; BUFFER_WIDTH]; BUFFER_HEIGHT], // 2D array
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pub struct  Writer {
\end_layout

\begin_layout Plain Layout

    column_position: usize,
\end_layout

\begin_layout Plain Layout

    row_position: usize,
\end_layout

\begin_layout Plain Layout

    buffer: &'static mut Buffer,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We don't need to define the Buffer, row_position, column_position, and other
 fields in main, so they can be made private again.
\end_layout

\begin_layout Standard

\series bold
Step 4: Change lib.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#![no_std]
\end_layout

\begin_layout Plain Layout

mod vga;
\end_layout

\begin_layout Plain Layout

pub use vga::WRITER;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We export WRITER only.
\end_layout

\begin_layout Standard

\series bold
Step 5: Clear screen
\end_layout

\begin_layout Standard
Add a function clear screen to reset the output window
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

impl Writer {
\end_layout

\begin_layout Plain Layout

    pub fn clear_screen(&mut self) {
\end_layout

\begin_layout Plain Layout

        for row in 0..BUFFER_HEIGHT {
\end_layout

\begin_layout Plain Layout

            self.clear_row(row);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        self.column_position = 0;
\end_layout

\begin_layout Plain Layout

        self.row_position = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For now, you can call function by using
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WRITER.lock().clear_screen();
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Test
\end_layout

\begin_layout Standard
In main.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

use chronos_labs::WRITER;
\end_layout

\begin_layout Plain Layout

use core::fmt::Write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start() {
\end_layout

\begin_layout Plain Layout

    for i in 0..5 {
\end_layout

\begin_layout Plain Layout

        writeln!(WRITER.lock(), "Hello World {}", i).unwrap();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // WRITER.lock().clear_screen();   // uncomment this line to clear the
 screen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Imports the WRITER static variable from the vga module and import core::fmt::Wri
te to use writeln! write! and writeln! is called 
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-02-17 19-22-01.png
	width 60page%

\end_inset


\end_layout

\begin_layout Chapter
Lab 3 - Keyboard Input
\end_layout

\begin_layout Section
Expected Outcome
\end_layout

\begin_layout Standard
This lab is relating to the hardware interruption in operating system, OS
 control input through interrupt.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-06 00-08-14.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
In this lab, you will implement the aspect of the operating system that
 manages interrupts and hardware input.
\end_layout

\begin_layout Section
Task 1 - Setup interrupt
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this task, we need to create an interrupt module and define the IDT (Interrup
t Descriptor Table).
 We'll test it using a breakpoint exception.
 We will handle breakpoint interrupts by defining a custom function in IDT.
 By checking the IDT, the OS can find the right function to handle interrupt
 output.
\end_layout

\begin_layout Standard
More about IDT please see here
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Interrupt-Descriptor-Table"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add dependency
\end_layout

\begin_layout Standard
In Cargo.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies] 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

x86_64 = "0.14.2"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The x86_64 crate provides interfaces for manipulating the IDT.
\end_layout

\begin_layout Standard

\series bold
Step 2: Create src/interrupts.rs
\end_layout

\begin_layout Standard
To better maintain and read the code, as well as for future testing purposes,
 we use a separate file.
 First, we import modules and define functions.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use x86_64::structures::idt::InterruptDescriptorTable;
\end_layout

\begin_layout Plain Layout

use x86_64::structures::idt::InterruptStackFrame;
\end_layout

\begin_layout Plain Layout

use crate::WRITER;
\end_layout

\begin_layout Plain Layout

use core::fmt::Write;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Initialize Interrupt Descriptor Table
\end_layout

\begin_layout Standard
We need to initialize an IDT, ensuring it remains effective throughout the
 entire runtime of the program, while also being mutable.
 Therefore, we define it as a mutable static variable.
 Then, within the init_idt function, we specify the use of the breakpoint
 function to handle breakpoint interrupts.
 Next, we will define the breakpoint function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static mut ID: InterruptDescriptorTable = InterruptDescriptorTable::new();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pub fn init_idt() {
\end_layout

\begin_layout Plain Layout

    unsafe {
\end_layout

\begin_layout Plain Layout

        ID.breakpoint.set_handler_fn(breakpoint);
\end_layout

\begin_layout Plain Layout

        ID.load();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 4: Create breakpoint function
\end_layout

\begin_layout Standard
The function will receive an interrupt stack frame (though we won't use
 it) and then output a prompt indicating that the function is working correctly.
 So we add a _ before stack_frame, indicate we won't use this variable.
 Or directly use _ as variable name.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extern "x86-interrupt" fn breakpoint(
\end_layout

\begin_layout Plain Layout

    _stack_frame: InterruptStackFrame)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(), "Break point works.
\backslash
n").unwrap();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
extern "x86-interrupt" fn breakpoint: This indicates that the function is
 an interrupt function, unlike regular functions.
 It needs to automatically save and restore all registers to prevent changes
 in the program's state during interrupt handling.
\end_layout

\begin_layout Standard
More about interrupt stack frame please see here.
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Interrupt-Stack-Frame"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 5: Enable on main
\end_layout

\begin_layout Standard
We should make module interrupts public at lib.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub mod interrupts;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Load ID and enable interrupt at main.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use chronos_labs::interrupts; 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start() -> !{
\end_layout

\begin_layout Plain Layout

    interrupts::init_idt();
\end_layout

\begin_layout Plain Layout

    x86_64::instructions::interrupts::int3(); // invoke a breakpoint exception
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // WRITER.lock().clear_screen();   // uncomment this line to clear the
 screen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
The output will show that the breakpoint is working properly.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-09 16-54-23.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 2 - Timer
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this section, we need to introduce a Programmable Interrupt Controller
 (PIC) to assist us in handling hardware interrupts.
 We'll try using a timer here, setting it up to regularly print underscores
 to check if it's working properly.
 Here we will use Intel 8259 PIC.
 This kind of PIC typically comes in two pieces, a main one and a secondary
 one.
 However, in our project, we only need to use the first two ports of the
 main PIC.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-09 23-19-57.png
	width 60page%

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "key-10"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add dependency
\end_layout

\begin_layout Standard
In Cargo.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies]
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

pic8259 = "0.10.1"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And add it into src/interrupts.rs, also with a mutex
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use spin::Mutex;
\end_layout

\begin_layout Plain Layout

use pic8259::ChainedPics;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Initialize PIC
\end_layout

\begin_layout Standard
We need to initialize the PIC.
 Here, we've created a mutex lock because we only want one interrupt handler
 to access and modify the ChainedPics object at a time to prevent data race.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub static PICS: Mutex<ChainedPics> = Mutex::new(unsafe { ChainedPics::new(0,
 8) });
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
ChainedPics::new(0, 8): Here, 0 and 8 respectively represent the offsets
 for the primary and secondary PICs.
 Remember, each PIC has eight interrupt lines, so the timer we want to access
 is the first one
\end_layout

\begin_layout Standard

\series bold
Step 3: Set timer function
\end_layout

\begin_layout Standard
We modify init_idt
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub fn init_idt() {
\end_layout

\begin_layout Plain Layout

    unsafe {
\end_layout

\begin_layout Plain Layout

        ID.breakpoint.set_handler_fn(breakpoint);
\end_layout

\begin_layout Plain Layout

        ID.load();
\end_layout

\begin_layout Plain Layout

        ID[0].set_handler_fn(timer);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Indicate the function handle with the first line of PIC is timer.
\end_layout

\begin_layout Standard

\series bold
Step 4: Create timer function
\end_layout

\begin_layout Standard
Similar as the breakpoint function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extern "x86-interrupt" fn timer(_: InterruptStackFrame)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    write!(WRITER.lock(), "_").unwrap();
\end_layout

\begin_layout Plain Layout

    unsafe {
\end_layout

\begin_layout Plain Layout

        PICS.lock()
\end_layout

\begin_layout Plain Layout

            .notify_end_of_interrupt(0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But we need to notify the end of interruption in this function, or the system
 will only output only one underscore.
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
The output will continuously print underscores.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-06 00-55-31.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 3 - Keyboard input
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this task, we will handle keyboard input (specifically from a PS/2 keyboard).
 Similar to other interrupts, when a user presses or releases a key on the
 keyboard, the computer receives corresponding scan codes.
 Therefore, we need to read and translate these scan codes.
 Here, we will read and translate the scan codes for the numbers 0 to 9
 on the main keyboard, as well as on the numeric keypad, along with the
 period (.) symbol.
 For more about the scancode please see the osdev wiki here 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://wiki.osdev.org/Keyboard#Scan_Code_Set_1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add dependency
\end_layout

\begin_layout Standard
The keyboard will send scancode to the system, at this point it will send
 to port 0x60
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use x86_64::instructions::port::Port;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Set keyboard function
\end_layout

\begin_layout Standard
Similar as timer, we set keyboard function to 1
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        ID[0].set_handler_fn(timer_off);
\end_layout

\begin_layout Plain Layout

        ID[1].set_handler_fn(keyboard);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Create keyboard function
\end_layout

\begin_layout Standard
We create the function and initialize port to receive the scancode.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extern "x86-interrupt" fn keyboard(_: InterruptStackFrame)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    let mut port = Port::new(0x60);
\end_layout

\begin_layout Plain Layout

    let scancode: u8 = unsafe { port.read() };
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Translate scancode
\end_layout

\begin_layout Standard
Use match to translate scancode, you can see more about match here
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Match"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Newline newline
\end_inset

Remember you could get the transcode on osdev wiki.
 We want the number print out when user press the button, not release the
 button.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let mut key: Option<&str> = None;
\end_layout

\begin_layout Plain Layout

    key = match scancode {
\end_layout

\begin_layout Plain Layout

        0x02 | 0x4F => Some("1"),
\end_layout

\begin_layout Plain Layout

        0x03 | 0x50 => Some("2"),
\end_layout

\begin_layout Plain Layout

        0x04 | 0x51 => Some("3"),
\end_layout

\begin_layout Plain Layout

        0x05 | 0x4B => Some("4"),
\end_layout

\begin_layout Plain Layout

        0x06 | 0x4C => Some("5"),
\end_layout

\begin_layout Plain Layout

        0x07 | 0x4D => Some("6"),
\end_layout

\begin_layout Plain Layout

        0x08 | 0x47 => Some("7"),
\end_layout

\begin_layout Plain Layout

        0x09 | 0x48 => Some("8"),
\end_layout

\begin_layout Plain Layout

        0x0a | 0x49 => Some("9"),
\end_layout

\begin_layout Plain Layout

        0x0b | 0x52 => Some("0"),
\end_layout

\begin_layout Plain Layout

        0x53 => Some("."),
\end_layout

\begin_layout Plain Layout

        _ => None,
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
key: Option<&str>: key could be a reference to a string (Some(&str)), or
 it might have no value (None)
\end_layout

\begin_layout Standard

\series bold
Step 4: Output key
\end_layout

\begin_layout Standard
As same as timer, remember to end the interrupt when finish output.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    if let Some(key) = key {
\end_layout

\begin_layout Plain Layout

        writeln!(WRITER.lock(), "{}", key);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsafe {
\end_layout

\begin_layout Plain Layout

        PICS.lock()
\end_layout

\begin_layout Plain Layout

            .notify_end_of_interrupt(1);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
You could set timer to output nothing (change 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

) if you find that is a bit messy.
\end_layout

\begin_layout Standard
Using the numeric keypad and number keys for input, you will see the VGA
 display showing the corresponding numbers and decimal points.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-06 00-57-13.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 4 - Enable numlock
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In daily use, we often find that a single key can represent multiple characters.
 We use various methods such as capslock, numlock, or pressing Shift to
 toggle output.
 Here, let's take numlock as an example.
 When we press numlock it will change the output content.
 If your computer does not support the numeric keypad, you can also set
 it to another key.
 However, remember that VGA has limited support for output and cannot output
 all symbols.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Create numlock value
\end_layout

\begin_layout Standard
The numlock should be a static boolean value default to false, it needs
 to be accessed and modified throughout the entire program.
 Similar as the PICS 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static NUMLOCK: Mutex<bool> = Mutex::new(false);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2 : Get and change the numlock
\end_layout

\begin_layout Standard
Do it inside the keyboard function.
 We need to get the mutex lock, and when user press down numlock, flipping
 the state of the numlock key.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let mut key: Option<&str> = None; 
\end_layout

\begin_layout Plain Layout

let mut numlock = NUMLOCK.lock();
\end_layout

\begin_layout Plain Layout

    if scancode == 0x45 {
\end_layout

\begin_layout Plain Layout

        *numlock = !*numlock;
\end_layout

\begin_layout Plain Layout

        key = Some("numlock");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
*numlock: numlock is a mutable reference to a boolean value that is protected
 by a mutex.
 So *numlock is dereferencing the numlock reference.
 It will access the boolean value
\end_layout

\begin_layout Standard

\series bold
Step 3: Handle different input
\end_layout

\begin_layout Standard
When we obtain the value of numlock, we can differentiate input into two
 cases: Num Lock on and off.
 Complete this if statement to accomplish the conversion.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

else if !*numlock {
\end_layout

\begin_layout Plain Layout

        key = match scancode {
\end_layout

\begin_layout Plain Layout

            0x02 | 0x4F => Some("1"),
\end_layout

\begin_layout Plain Layout

            0x03 | 0x50 => Some("2"),
\end_layout

\begin_layout Plain Layout

            0x04 | 0x51 => Some("3"),
\end_layout

\begin_layout Plain Layout

            0x05 | 0x4B => Some("4"),
\end_layout

\begin_layout Plain Layout

            0x06 | 0x4C => Some("5"),
\end_layout

\begin_layout Plain Layout

            0x07 | 0x4D => Some("6"),
\end_layout

\begin_layout Plain Layout

            0x08 | 0x47 => Some("7"),
\end_layout

\begin_layout Plain Layout

            0x09 | 0x48 => Some("8"),
\end_layout

\begin_layout Plain Layout

            0x0a | 0x49 => Some("9"),
\end_layout

\begin_layout Plain Layout

            0x0b | 0x52 => Some("0"),
\end_layout

\begin_layout Plain Layout

            0x53 => Some("."),
\end_layout

\begin_layout Plain Layout

            _ => None,
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        key = match scancode {
\end_layout

\begin_layout Plain Layout

            0x02 => Some("1"),
\end_layout

\begin_layout Plain Layout

            0x03 => Some("2"),
\end_layout

\begin_layout Plain Layout

            0x04 => Some("3"),
\end_layout

\begin_layout Plain Layout

            0x05 => Some("4"),
\end_layout

\begin_layout Plain Layout

            0x06 | 0x4C => Some("5"),
\end_layout

\begin_layout Plain Layout

            0x07 => Some("6"),
\end_layout

\begin_layout Plain Layout

            0x08 => Some("7"),
\end_layout

\begin_layout Plain Layout

            0x09 => Some("8"),
\end_layout

\begin_layout Plain Layout

            0x0a => Some("9"),
\end_layout

\begin_layout Plain Layout

            0x0b => Some("0"),
\end_layout

\begin_layout Plain Layout

            0x4F => Some("end"),
\end_layout

\begin_layout Plain Layout

            0x50 => Some("DownArrow"),
\end_layout

\begin_layout Plain Layout

            0x51 => Some("PageDown"),
\end_layout

\begin_layout Plain Layout

            0x4B => Some("LeftArrow"),
\end_layout

\begin_layout Plain Layout

            0x4D => Some("RightArrow"),
\end_layout

\begin_layout Plain Layout

            0x47 => Some("home"),
\end_layout

\begin_layout Plain Layout

            0x48 => Some("UpArrow"),
\end_layout

\begin_layout Plain Layout

            0x49 => Some("PageUp"),
\end_layout

\begin_layout Plain Layout

            0x52 => Some("Insert"),
\end_layout

\begin_layout Plain Layout

            0x53 => Some("Delete"),
\end_layout

\begin_layout Plain Layout

            _ => None,
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is just an example; you can implement your own conversion and keyboard
 output.
 Don't forget to output and end the interrupt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if let Some(key) = key {
\end_layout

\begin_layout Plain Layout

        writeln!(WRITER.lock(), "{}", key);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsafe {
\end_layout

\begin_layout Plain Layout

        PICS.lock()
\end_layout

\begin_layout Plain Layout

            .notify_end_of_interrupt(1);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
By using the Num Lock key, you can change the output on the numeric keypad.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-04-06 00-58-26.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
The Rust Embedded community also provides a fantastic PS/2 keyboard implementati
on that you can try using directly or refer to for implementing more keyboard
 inputs yourself!
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/rust-embedded-community/pc-keyboard
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Lab 4 - Paging
\end_layout

\begin_layout Section
Expected Outcome
\end_layout

\begin_layout Standard
In this lab you will learn how the OS is manipulate the memory.
 This is relating to the memory management of the Operating system.
\end_layout

\begin_layout Standard

\series bold
This part is associated with CS257:Advanced Computer Architecture's virtual
 memory section.
 It is strongly recommended that you complete this lab after studying/reviewing
 that course.
\end_layout

\begin_layout Standard
In this lab, we will be able to understand paging, translate virtual address
 to physical address and create mapping.
 Because this kernel is built on x86_64 architecture and using bootloader,
 it is already support multilevel page tables.
 
\end_layout

\begin_layout Section
Quick Overview
\end_layout

\begin_layout Standard
If you're not very clear on the concepts of virtual addresses and physical
 addresses, please check here.
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Virtual-Address-&"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/sDyyu.png
	width 50page%

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "key-8"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Paging is a memory management technique in computers.
 It maps a process's virtual address space to physical memory.
 Physical memory is divided into fixed-size blocks called "pages," and the
 process's virtual address space is divided into equally sized blocks called
 "page frames." The operating system uses a page table to track the mapping
 between virtual and physical addresses.
 When a process accesses a virtual address, the operating system translates
 it into the corresponding physical address using the page table, enabling
 virtual memory.
 
\begin_inset Newline newline
\end_inset

In our operating system, virtual addresses map to the entire physical address
 space, allowing them to access any physical address.
 To avoid conflicts with actual addresses, we use a larger offset, such
 as 1T.
 This ensures that virtual addresses do not overlap with physical addresses.
\begin_inset Newline newline
\end_inset

The process of translating virtual addresses into physical addresses will
 be gradually introduced and implemented step by step in the upcoming labs.
\end_layout

\begin_layout Section
Task 1 - Get in touch with L4 table
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this task, we will access the CR3 register to obtain the physical address
 of the L4 page table.
 Then we need to virtual page that is mapped to the physical frame at address
 0x1000 because we can't directly access physical address due to security
 reason.
 After that, we will traverse the L4 page table, print non-empty entries,
 and obtain the information stored in the L3 page table.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add dependency
\end_layout

\begin_layout Standard
Edit Cargo.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[dependencies]
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

bootloader = { version = "0.9", features = ["map_physical_memory"]}
\end_layout

\begin_layout Plain Layout

x86_64 = "0.14.2" 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We need one more feature support of bootloader, and the support of x86_64
 crate for page table support.
\end_layout

\begin_layout Standard

\series bold
Step 2: Read CR3 register
\end_layout

\begin_layout Standard
More about CR3
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:CR3-register"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The CR3 register stores the physical address of the L4 page table we want
 to access.
 Let's access it and print out the address of the L4 page table.
 Edit src/main.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

use x86_64::registers::control::Cr3;
\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start(boot_info: &'static BootInfo) -> ! {
\end_layout

\begin_layout Plain Layout

    let (l4_entry, _) = Cr3::read();
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),
\end_layout

\begin_layout Plain Layout

             "Level 4 page table at: {:?}",
\end_layout

\begin_layout Plain Layout

             l4_entry.start_address()
\end_layout

\begin_layout Plain Layout

    ).unwrap();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
_ means we will not using this variable, so just ignore it.
\end_layout

\begin_layout Standard
We could get the output of address
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 17-14-07.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Get physical memory offset
\end_layout

\begin_layout Standard
We need to read the physical memory offset in the boot_info, so our function
 should accept boot_info as input parameter.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

use bootloader::BootInfo; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start(boot_info: &'static BootInfo) -> ! {
\end_layout

\begin_layout Plain Layout

    let (l4_entry, _) = Cr3::read();
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),
\end_layout

\begin_layout Plain Layout

             "Level 4 page table at: {:?}",
\end_layout

\begin_layout Plain Layout

             l4_entry.start_address()
\end_layout

\begin_layout Plain Layout

    ).unwrap();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    let phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),
\end_layout

\begin_layout Plain Layout

             "Physical memory offset: {:?}",
\end_layout

\begin_layout Plain Layout

             phys_mem_offset
\end_layout

\begin_layout Plain Layout

    ).unwrap();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then we could get the physical memory offset to create the virtual page.
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 18-10-28.png
	width 60page%

\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Step 4: Create virtual page mapped to 0x1000
\end_layout

\begin_layout Standard
We could get the virtual address by physical address + physical page offset.
 Add under phys_mem_offset
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

use x86_64::structures::paging::PageTable;
\end_layout

\begin_layout Plain Layout

use x86_64::VirtAddr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    let virt = phys_mem_offset + l4_entry.start_address().as_u64();
\end_layout

\begin_layout Plain Layout

    let l4_ptr: *mut PageTable = virt.as_mut_ptr();
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(), "Virtual address: {:?}", l4_ptr).unwrap();
\end_layout

\begin_layout Plain Layout

    let l4_table = unsafe { &*l4_ptr };
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
let l4_ptr: *mut PageTable : It declares variable l4_ptr in type *mut PageTable.
 *mut PageTable is the type of the variable.
 It's a mutable pointer (*mut) to a PageTable.
 
\end_layout

\begin_layout Standard
Then we could see the virtual address of page.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 18-15-48.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 5: Traverse the L4 page table
\end_layout

\begin_layout Standard
Under l4_table
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (i, entry) in l4_table.iter().enumerate() {
\end_layout

\begin_layout Plain Layout

        // try to print all entries?
\end_layout

\begin_layout Plain Layout

        // writeln!(WRITER.lock(), "L4 Entry {}: {:?}", i, entry).unwrap();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if !entry.is_unused() {
\end_layout

\begin_layout Plain Layout

            writeln!(WRITER.lock(), "L4 Entry {}: {:?}", i, entry).unwrap();
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
.iter(): It is a method is used to create an iterator over a collection.
 It returns an iterator that allows you to iterate over the elements of
 the collection.
\end_layout

\begin_layout Itemize
.enumerate(): It yields tuples containing the index and the corresponding
 value from the original iterator.
\end_layout

\begin_layout Standard
We print only non-empty entries in the page table because it helps us focus
 on relevant information.
 Printing all entries might overwhelm us with unnecessary data, making it
 harder to understand the page table's structure and content.
 However, you can print all entries if you want to experiment and inspect
 thoroughly.
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
The output will display the physical address of the L4 page table stored
 in the CR3 register, along with the output of each non-empty entry in the
 L4 page table.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 12-27-51.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
We also can have a look of all entries in L4 table
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 12-58-57.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 2 - Traverse four-level page table
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this task, we will learn how to read entries in the page table and use
 this information to access the next level of the page table.
 This task is similar to reading CR3 and generating the physical address
 at a specified location.
 However, to maintain readability, we limit the output to only the first
 few non-empty entries.
 In the labsheet, I will demonstrate how to print the L4 and L3 page tables.
 You can implement the methods for printing the L2 and L1 page tables by
 yourself.
 Of course, the solution would be available at branch lab4-2.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Add limitation
\end_layout

\begin_layout Standard
Add constant to limit how many non-empty entry you want to show.
 We set 2 for now.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

use x86_64::VirtAddr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

const DISPLAY_ENTRY: i32 = 2;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then define the counter:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

let l4_table = unsafe { &*l4_ptr };
\end_layout

\begin_layout Plain Layout

    // counter
\end_layout

\begin_layout Plain Layout

    let mut l4_counter = 0;
\end_layout

\begin_layout Plain Layout

    let mut l3_counter = 0;
\end_layout

\begin_layout Plain Layout

    for (i, entry) in l4_table.iter().enumerate() {
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 2: Show first 2 entries of L4
\end_layout

\begin_layout Standard
In each loop, increment the counter by 1.
 Then check weather l4_counter is less then DISPLAY_ENTRY
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    for (i, entry) in l4_table.iter().enumerate() {
\end_layout

\begin_layout Plain Layout

        if !entry.is_unused() && l4_counter < DISPLAY_ENTRY {
\end_layout

\begin_layout Plain Layout

            writeln!(WRITER.lock(), "L4 Entry {}: {:?}", i, entry).unwrap();
\end_layout

\begin_layout Plain Layout

            l4_counter += 1;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We could see the output
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 19-11-33.png
	width 60page%

\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Step 3: Access L3 page table
\end_layout

\begin_layout Standard
To read the entries in the L4 page table, you can follow a similar approach
 to reading the address stored in CR3.
 Create a new page table that points to this physical address.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            let phys = entry.frame().unwrap().start_address();
\end_layout

\begin_layout Plain Layout

            let virt = phys.as_u64() + boot_info.physical_memory_offset;
\end_layout

\begin_layout Plain Layout

            let l3_ptr = VirtAddr::new(virt).as_mut_ptr();
\end_layout

\begin_layout Plain Layout

            let l3_table: &PageTable = unsafe { &*l3_ptr };
\end_layout

\begin_layout Plain Layout

            write!(WRITER.lock(), "L3 table at: {:p}", l3_ptr).unwrap();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 19-15-24.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard
We can observe that this virtual address consists of a entry plus a physical
 memory offset.
\end_layout

\begin_layout Standard

\series bold
Step 4: Traverse L3 page table
\end_layout

\begin_layout Standard
We access each L3 page table pointed to by the printed L4 entries.
 After iterating through each L3 page table, we reset the counter to zero.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            // print non-empty entries of the level 3 table
\end_layout

\begin_layout Plain Layout

            for (i, entry) in l3_table.iter().enumerate() {
\end_layout

\begin_layout Plain Layout

                if !entry.is_unused()  && l3_counter < DISPLAY_ENTRY{
\end_layout

\begin_layout Plain Layout

                    writeln!(WRITER.lock(), "   L3 Entry {}: {:?}", i, entry).unwr
ap();
\end_layout

\begin_layout Plain Layout

                    l3_counter += 1;
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            l3_counter = 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-24 19-32-25.png
	width 60page%

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 5: Extend to L2 and L1
\end_layout

\begin_layout Standard
Due to space constraints and the similarity of the implementation steps
 to L3, we won't expand on it here.
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
This is the output when we only display first entry of every level of table.
 For here we limit to just print the first non-empty entry.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-11 22-12-56.png
	width 60page%

\end_inset


\end_layout

\begin_layout Section
Task 3 - Address translation
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Here we will combine what we've done before, traversing the four-level page
 table and adding the physical offset to complete the translation from virtual
 addresses to physical addresses.
\end_layout

\begin_layout Standard
We will create a function that reads a virtual address and a physical offset
 value, obtains the index of each level of the page table, traverses the
 page table, and then obtains the final physical address, adding the offset
 for output.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-27 12-31-42.png
	width 60page%

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "key-9"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard

\series bold
Step 1: Create src/memory.rs
\end_layout

\begin_layout Standard
To better maintain and read the code, as well as for future testing purposes,
 we use a separate file.
 First, we import modules and define functions.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use x86_64::structures::paging::PageTable;
\end_layout

\begin_layout Plain Layout

use x86_64::PhysAddr;
\end_layout

\begin_layout Plain Layout

use x86_64::VirtAddr;
\end_layout

\begin_layout Plain Layout

use x86_64::registers::control::Cr3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pub unsafe fn translate_address(addr: VirtAddr, physical_memory_offset:
 VirtAddr)
\end_layout

\begin_layout Plain Layout

                        -> Option<PhysAddr>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we need to read registers, reference, and dereference raw pointers,
 this function is unsafe.
\end_layout

\begin_layout Itemize

\series bold
Option<PhysAddr>
\series default
: This mean this function may return PhysAddr or return None
\end_layout

\begin_layout Standard

\series bold
Step 2: Get L4 frame
\end_layout

\begin_layout Standard
Do similar as previous task.
 We read CR3 and get the frame address.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    let (l4_frame, _) = Cr3::read();
\end_layout

\begin_layout Plain Layout

    let mut frame_addr = l4_frame;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 3: Get indexes of each table
\end_layout

\begin_layout Standard
As the figure shown in introduction, we could get the index of each level.
 It is used to gain the address of next table.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let table_offset = [
\end_layout

\begin_layout Plain Layout

        addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index()
\end_layout

\begin_layout Plain Layout

    ];
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Step 4: Traverse the page table
\end_layout

\begin_layout Standard
Using a for loop to traverse all 4 table
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// traverse the page table to find the frame corresponding to the address
\end_layout

\begin_layout Plain Layout

    for &index in &table_offset {
\end_layout

\begin_layout Plain Layout

        // calculate the virtual address of the next table
\end_layout

\begin_layout Plain Layout

        let virt = physical_memory_offset + frame_addr.start_address().as_u64();
\end_layout

\begin_layout Plain Layout

        let table_ptr: *const PageTable = virt.as_ptr();
\end_layout

\begin_layout Plain Layout

        let table = unsafe {&*table_ptr};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // get the frame from the table entry and update the frame address
\end_layout

\begin_layout Plain Layout

        let entry = &table[index];
\end_layout

\begin_layout Plain Layout

        frame_addr = match entry.frame() {
\end_layout

\begin_layout Plain Layout

            Ok(frame) => frame,
\end_layout

\begin_layout Plain Layout

            Err(_) => return None
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first paragraph is similar to handling Task 2, but we need to obtain
 specific entries.
 So we get rentry from &table[index].
 Then is exception handling part, if the entry is not exist, the function
 will return None.
\end_layout

\begin_layout Standard

\series bold
Step 5: Return address
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

frame_addr = match entry.frame() {
\end_layout

\begin_layout Plain Layout

            Ok(frame) => frame,
\end_layout

\begin_layout Plain Layout

            Err(_) => return None
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // calculate the physical address
\end_layout

\begin_layout Plain Layout

    Some(frame_addr.start_address() + u64::from(addr.page_offset()))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For Rust function,it implicitly return the value of the last expression
 evaluated.
 Some(T) is used when there is a value and it wraps the value inside.
 
\end_layout

\begin_layout Standard

\series bold
Step 6: Print out translation result
\end_layout

\begin_layout Standard
Remember add this module into lib.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub mod translate;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the main.rs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use chronos_labs::WRITER;
\end_layout

\begin_layout Plain Layout

use core::fmt::Write;
\end_layout

\begin_layout Plain Layout

use bootloader::BootInfo;
\end_layout

\begin_layout Plain Layout

use x86_64::VirtAddr;
\end_layout

\begin_layout Plain Layout

use chronos_labs::translate::translate_address;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#[no_mangle]    // don't mangle the name of this function
\end_layout

\begin_layout Plain Layout

pub extern "C" fn _start(boot_info: &'static BootInfo) -> !{
\end_layout

\begin_layout Plain Layout

    let phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // try to translate some addresses
\end_layout

\begin_layout Plain Layout

    // the VGA buffer page
\end_layout

\begin_layout Plain Layout

    let virt_VGA = VirtAddr::new(0xb8000);
\end_layout

\begin_layout Plain Layout

    let phys_VGA = unsafe { translate_address(virt_VGA, phys_mem_offset)
 };
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),"Translate from virtual address from {:?} to physical
 address {:?}", virt_VGA, phys_VGA);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // exsting page
\end_layout

\begin_layout Plain Layout

    let virt_existing = VirtAddr::new(0x201008);
\end_layout

\begin_layout Plain Layout

    let phys_existing = unsafe { translate_address(virt_existing, phys_mem_offse
t) };
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),"Translate from virtual address from {:?} to physical
 address {:?}", virt_existing, phys_existing);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // non-existing page
\end_layout

\begin_layout Plain Layout

    let virt_non_existing = VirtAddr::new(0xffffffffc0000000);
\end_layout

\begin_layout Plain Layout

    let phys_non_existing = unsafe { translate_address(virt_non_existing,
 phys_mem_offset) };
\end_layout

\begin_layout Plain Layout

    writeln!(WRITER.lock(),"Translate from virtual address from {:?} to physical
 address {:?}", virt_non_existing, phys_non_existing);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    loop {}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we write in VGA, it is virtual address but this is special case that,
 physical address is as same as virtual.
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Standard
You would get the output of the translation from virtual address to physical
 address.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-03-26 23-34-26.png
	width 60page%

\end_inset


\end_layout

\begin_layout Chapter
Utility - Test tool
\end_layout

\begin_layout Standard

\series bold
\size huge
\color red
Before using it, remember to comment
\end_layout

\begin_layout Standard
in Cargo.toml
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#[profile.dev]
\end_layout

\begin_layout Plain Layout

#panic = "abort"
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lab 2
\end_layout

\begin_layout Standard
The test is available at branch 
\begin_inset CommandInset href
LatexCommand href
name "test-lab2"
target "https://github.com/acyanbird/chronos_labs/tree/test-lab2"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
If you want to add them to your code add this function to vga.rs.
 And copy and paste tests folder.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

impl Writer {
\end_layout

\begin_layout Plain Layout

    pub fn get_ascii(&mut self, row: usize, col: usize) -> u8 {
\end_layout

\begin_layout Plain Layout

        self.buffer.chars[row][col].read().ascii
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo test --test lab2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And for the exception handling, make sure you provide blue color for the
 exception, or the test would fail.
\end_layout

\begin_layout Section
Lab 3
\end_layout

\begin_layout Standard
The test is available at branch 
\begin_inset CommandInset href
LatexCommand href
name "test-lab3"
target "https://github.com/acyanbird/chronos_labs/tree/test-lab3"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Make NUMLOCK public to run test
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pub static NUMLOCK: Mutex<bool> = Mutex::new(false);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo test --test lab3
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lab 4
\end_layout

\begin_layout Standard
The test is available at branch 
\begin_inset CommandInset href
LatexCommand href
name "test-lab4"
target "https://github.com/acyanbird/chronos_labs/tree/test-lab4"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
It will check the translate function.
\end_layout

\begin_layout Standard
Using command
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cargo test --test lab4
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Extra knowledge
\end_layout

\begin_layout Section
Calling convention
\begin_inset CommandInset label
LatexCommand label
name "sec:Calling-convention"

\end_inset


\end_layout

\begin_layout Standard
Calling conventions are a standardized method for functions to be implemented
 and called by the machine.
 A calling convention specifies the method that a compiler sets up to access
 a subroutine.
\begin_inset CommandInset citation
LatexCommand cite
key "key-7"
literal "false"

\end_inset

 Here's a simple C code example demonstrating a function call using the
 cdecl convention:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=C"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int add(int a, int b) {
\end_layout

\begin_layout Plain Layout

    return a + b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int result = add(3, 5);  // Function call using cdecl
\end_layout

\begin_layout Plain Layout

    printf("The result is: %d
\backslash
n", result);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Add function takes two integers as arguments and returns their sum.
\end_layout

\begin_layout Itemize
When add(3, 5) is called, 5 is pushed onto the stack first, followed by
 3.
\end_layout

\begin_layout Itemize
After add returns, the main function cleans up the stack by removing the
 two arguments.
\end_layout

\begin_layout Itemize
The sum, which is the return value of add, is placed in the EAX register
 (on x86) and then stored in the result variable.
\end_layout

\begin_layout Standard
We use the C calling convention because it is widely recognized, while Rust
 does not yet have a stable calling convention released, as it is still
 under development.
 See 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://internals.rust-lang.org/t/pre-rfc-interrupt-calling-conventions/16182"
literal "false"

\end_inset


\end_layout

\begin_layout Section
What did bootimage tool do?
\begin_inset CommandInset label
LatexCommand label
name "sec:What-did-bootimage"

\end_inset


\end_layout

\begin_layout Standard
The process of booting a system is a complex topic.
 You can find more information about it 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://wiki.ubuntu.com/Booting"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The BIOS will wake up the bootloader, which first compiles all dependencies
 into a standalone executable.
 Then, it compiles our kernel into an ELF file and jumps to the _start function
 to begin execution.
\end_layout

\begin_layout Section
VGA text buffer
\begin_inset CommandInset label
LatexCommand label
name "sec:VGA-text-buffer"

\end_inset


\end_layout

\begin_layout Standard
The VGA (Video Graphics Array) text buffer is a specific area of memory
 used to display text on the screen in a text-mode environment.
 It is located at the memory address 0xB8000.
 It extends to 0xB8FA0, covering a space that allows for 25 lines of 80
 characters each, making up the standard 80x25 text mode.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{
\backslash
baselineskip}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each character in the VGA text buffer is represented by two bytes:
\end_layout

\begin_layout Standard
The first byte represents the ASCII code of the character, determining which
 character to display.
 The second byte defines the color of the character, with the lower 4 bits
 specifying the foreground color and the upper 4 bits the background color.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{
\backslash
baselineskip}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/lucia/Pictures/Screenshots/Screenshot from 2024-01-29 14-47-58.png
	width 60page%

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset


\end_layout

\begin_layout Section
Big endian and little endian
\begin_inset CommandInset label
LatexCommand label
name "sec:Big-endian-and"

\end_inset


\end_layout

\begin_layout Standard
Big endian and little endian are two ways of ordering bytes in multi-byte
 data types.
 The difference lies in the order in which the bytes are stored in memory,
 we are using little endian according to the target specification file.
 In a little endian system, the least significant byte (LSB) is stored at
 the lowest memory address.
 Conversely, in a big endian system, it's the opposite.
 Here is the example
\end_layout

\begin_layout Standard
We have structure VGAChar
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=no language,language=rust"
inline false
status open

\begin_layout Plain Layout

struct VGAChar {
\end_layout

\begin_layout Plain Layout

    ascii: u8,
\end_layout

\begin_layout Plain Layout

    color: u8,
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you create a VGAChar with an ascii of 0x41 ('A') and a color of 0x04,
 it would be stored in memory as 41 04 in a little endian system.
 This is because ascii_character is the first field in the struct, so it
 gets the lower memory address.
\end_layout

\begin_layout Section
Interrupt Descriptor Table
\begin_inset CommandInset label
LatexCommand label
name "sec:Interrupt-Descriptor-Table"

\end_inset


\end_layout

\begin_layout Standard
The IDT is essentially a data structure used by the operating system to
 handle interrupts and exceptions.
 When something interrupt the working system, it needs to know what to do.
 That's where the IDT comes in.
 The operating system looks up the IDT and picks the right function to handle
 the interrupt.
 In our case in lab 3 task 1, we declare a breakpoint function to handle
 the breakpoint interrupt.
\end_layout

\begin_layout Section
Interrupt Stack Frame
\begin_inset CommandInset label
LatexCommand label
name "sec:Interrupt-Stack-Frame"

\end_inset


\end_layout

\begin_layout Standard
nterrupt Stack Frame is like a special note that a computer uses to remember
 what it was doing whenever it has to suddenly stop and do something else.
 Before the system jump to handle interrupt, the computer uses the Interrupt
 Stack Frame to write down details about the task it was doing.
 Then, it goes to address the interrupt.
 After dealing with the interrupt, the computer looks back at the Interrupt
 Stack Frame, sees where it left off, and resumes its original task.
\end_layout

\begin_layout Section
Virtual Address & Physical Address
\begin_inset CommandInset label
LatexCommand label
name "sec:Virtual-Address-&"

\end_inset


\end_layout

\begin_layout Standard
Virtual addresses and physical addresses both serve as pointers to data
 storage locations, but they operate differently.
 
\begin_inset Newline newline
\end_inset


\series bold
Virtual address 
\series default
is like a label created by the CPU for programs to use when they want to
 access memory.
 It helps programs talk to memory without worrying about where exactly things
 are stored physically.
 It can be seen as an abstraction of actual physical storage devices.
 Different processes can have the same virtual address, but physical addresses
 are unique.
\begin_inset Newline newline
\end_inset


\series bold
Physical address
\series default
 corresponds to a specific location in the physical memory (RAM) of a computer,
 representing an actual spot on the computer's memory hardware.
 It serves as a direct reference to where data is stored within the computer's
 memory system.
 The conversion between virtual addresses and physical addresses is the
 responsibility of the operating system.
\end_layout

\begin_layout Section
CR3 register
\begin_inset CommandInset label
LatexCommand label
name "sec:CR3-register"

\end_inset


\end_layout

\begin_layout Standard
CR3, or Control Register 3, is a special-purpose register in the x86 architectur
e used for memory management.
 It stores the base address of the page table of the currently running process.
 For our case, it is the physical address for level 4 page table.
 When the process changed, address in CR3 also changed.
 It ensures isolation between processes and efficient use of system resources.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

VGA text mode (2024) Wikipedia.
 Available at: https://en.wikipedia.org/wiki/VGA_text_mode (Accessed: 29 January
 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"
literal "false"

\end_inset

Learn rust (no date) Rust Programming Language.
 Available at: https://www.rust-lang.org/learn (Accessed: 13 February 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"
literal "false"

\end_inset

Klabnik, S.
 (2014) Rust by example, Introduction - Rust By Example.
 Available at: https://doc.rust-lang.org/rust-by-example/ (Accessed: 13 February
 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"
literal "false"

\end_inset

Rustlings (2015) rustlings.
 Available at: https://rustlings.cool/ (Accessed: 13 February 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"
literal "false"

\end_inset

Code page 437 (2024) Wikipedia.
 Available at: https://en.wikipedia.org/wiki/Code_page_437 (Accessed: 16 February
 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"
literal "false"

\end_inset

Trait core::fmt::write (no date) Rust.
 Available at: https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html (Accessed
: 17 February 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"
literal "false"

\end_inset

Cary, D.
 (2007) X86 disassembly/calling conventions, Wikibooks, open books for an
 open world.
 Available at: https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions
 (Accessed: 27 February 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-8"
literal "false"

\end_inset

Frank, M.
 (2013) On x86 architecture, why are there fewer bits for virtual address
 space than physical?, Super User.
 Available at: https://superuser.com/questions/655121/on-x86-architecture-why-are
-there-fewer-bits-for-virtual-address-space-than-phy (Accessed: 24 March
 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-9"
literal "false"

\end_inset

Oppermann, P.
 (2021) Introduction to paging, Introduction to Paging | Writing an OS in
 Rust.
 Available at: https://os.phil-opp.com/paging-introduction/ (Accessed: 27
 March 2024).
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-10"
literal "false"

\end_inset

Oppermann, P.
 (2018) Hardware interrupts, Hardware Interrupts | Writing an OS in Rust.
 Available at: https://os.phil-opp.com/hardware-interrupts/ (Accessed: 09
 April 2024).
 
\end_layout

\end_body
\end_document
